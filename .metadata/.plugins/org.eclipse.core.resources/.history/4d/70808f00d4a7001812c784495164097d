/**
 * 
 */
package net.File;

import java.io.IOException;

import java.nio.file.FileSystems;
import java.nio.file.Paths;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * @author jinyu
 * 监视目录
 */
public class FilesWatch {
	
private	WatchService watcher = null;
	private String dir;
	private Thread checkThread=null;
	private LinkedBlockingQueue<FileMonitor> queue=new LinkedBlockingQueue<FileMonitor>();
	private boolean isStop=false;
	public FilesWatch()
	{
		try {
			watcher = FileSystems.getDefault().newWatchService();
		} catch (IOException e) {
			
			e.printStackTrace();
		}
	}
	
	/**
	 * 
	* @Title: setWatch
	* @Description: 设置监视的目录
	* @param @param dir    参数
	* @return void    返回类型
	 */
	public void setWatch(String dir)
	{
		this.dir=dir;
	}
	
	/**
	 * 
	* @Title: stop
	* @Description: 停止监视
	* @param     参数
	* @return void    返回类型
	 */
	public void stop()
	{
		isStop=true;
	}
	
	/**
	 * 
	* @Title: take
	* @Description: 获取目录的变化信息
	* @param @return    参数
	* @return FileMonitor    返回类型
	 */
	public FileMonitor take()
	{
		try {
			return queue.take();
		} catch (InterruptedException e) {
			
			e.printStackTrace();
		}
		return null;
	}
	public void start()
	{
		checkThread =new Thread(new Runnable() {

			@Override
			public void run() {
				try
				{
				   Paths.get(dir).register(watcher,   
			                StandardWatchEventKinds.ENTRY_CREATE,  
			                StandardWatchEventKinds.ENTRY_DELETE,  
			                StandardWatchEventKinds.ENTRY_MODIFY);  
				}
				catch(Exception ex)
				{
					
				}
			        while (!isStop) {  
			            WatchKey key;
						try {
							key = watcher.take();
			            for (WatchEvent<?> event: key.pollEvents()) {  
			            	FileMonitor e=new FileMonitor();
			            	e.file=event.context().toString();
			            	e.kind=event.kind();
							queue.put(e);
			            }  
			              
			            boolean valid = key.reset();  
			            if (!valid) {  
			                break;  
			            }  
						} catch (InterruptedException e) {
							e.printStackTrace();
						} 
			        }  
			}
				
			
			
		});
		checkThread.setDaemon(true);
		checkThread.setName("monitor");
		checkThread.start();
}
}
